%title: Economic Exchange For Everyone Else
%author: James Edwards
%date: 2018-09-26

-> Step Transactions <-


   PurchaseStuffFromGameCrafter(
      'arg1',
      'arg2',
      Steps(
                  one('stuff'),
                  two('more stuff'),
      ),
   );
*========================================================*
My last presentation on this stuff went over like a lead
ballon. Nobody grooved on the Tau Station specific stuff.  
But creating a business transaction, NOT just a SQL 
transaction, is important.  Lets try migrate this to the 
real world.  And learn about FSA::Rules in the process.

-------------------------------------------------

->  Anonymous Sub Routine(s) Will Help <-

PurchaseStuffFromGameCrafter( 
      'arg1',
      'arg2', 
      Steps(
            one('stuff'),
      ),
);

*Turns into*

*Note*:   sub {my @x; say "anon steps"; return 99}  # is a ref to a sub

PurchaseStuffFromGameCrafter( 
      'arg1',
      'arg2', 
      (sub { one('stuff'); })->(), 
);

*========================================================*
This time I'm going to use anonymous subroutines
as the output of my source filter.

-------------------------------------------------

Kept on searching
   Tried a bunch of searches then one day
     Multi Step Transaction
     Business process Transaction
       Found reference to State Machine

   Perl State Machine
     Found a StackOverflow Q. about DFA::Simple
       Found a comment by Ovid about FSA::Rules
         FSA::Rules
           Authors
             David E. Wheeler
             Curtis "Ovid" Poe

   Seems a kool place to start

-------------------------------------------------

->  FSA::Rules. Example in POD  <-

  my $fsa = FSA::Rules->new(
     ping => {
         do => sub { print "ping!\n";
                     my $state = shift;
                     $state->result('pong');
                     $state->machine->{count}++;
         },
         rules =>[ game_over => sub { shift->machine->{count} >= 20 },
                   pong      => sub { shift->result eq 'pong'       },
         ],
     },
     pong => {
         do => sub { print "pong!\n" },
         rules => [ ping => 1, ], # always goes back to ping
     },
     game_over => { do => sub { print "Game Over\n" } }
  );
  $fsa->start;
  $fsa->switch until $fsa->at('game_over');
*========================================================*
There is plenty more to FSA::Rules. I'm just showing the a
small portion of the stuff I used.  

-------------------------------------------------

->  Lets remember my code <-

   PurchaseStuffFromGameCrafter(
      'arg1',
      'arg2',
      Steps(
             one('stuff'),
             two('more stuff'),
      ),
   );

-------------------------------------------------

->  My source code filter will... Part 1 <-

( sub {
   my $fsa = FSA::Rules->new(
   *step0* => {
      do => sub {
         my $rc = *one*('stuff');
         my $state = shift;
         $state->result($rc);
      },
   },
   *step1* => {
      do => sub {
         my $rc = *two*('more stuff');
         my $state = shift;
         $state->result($rc);
      },
   },
   ); # end of FSA::Rules->new()
   @behaviors = (undef, undef, );
   return stEps($fsa, 0, 4,\@behaviors);
   } # end of anonymous sub
)->()
);

-------------------------------------------------

->  My source code filter will append to the module ... Part 2 <-

# No testing of return codes of individual steps in my initial version
sub Steps { ... 
   *try* {
      begin_trans();
      for my $j ($beg..$end) {
        $fsa->curr_state("step$j");
      }
      end_trans();
   }
   *catch* {
      roll_back();
      die $_; # rethrow
   };
   return 1;
}
*========================================================*
If your modules has more than one 'Steps', why insert the
logic for handling the State Machine more than once.

To pull this off, I'm searching for '1;' at the end of the module. 
So current version only works with modules.

-------------------------------------------------

->  Will Handle *Behaviors* <-

   PurchaseSomeStuffFromGameCrafter(
      'arg1',
      'arg2',
      Steps(
         *ASSERT*(  func0() ),
                  func1(),
                  func2(),
         *FAILURE*( func3() ),
         *ALWAYS*(  func4() ),
      ),
   );

-------------------------------------------------

->  Behaviors <-

Stolen from Curtis 'Ovid' Poe

Posted on April 20, 2018
[Extending Economic Exchange Conditions](https://blog.taustation.space/blog/extending-economic-exchange-conditions/)

These behaviors alter the flow of steps:

*ASSERT*  – If this step fails, do not call any other steps for any reason.
*ALWAYS*  – Always run this step (unless an ASSERT was previously failed).
*FAILURE* – Run this step if any earlier step failed (unless an ASSERT was 
          previously failed).

-------------------------------------------------

->  jimE's rules  <-

We're keeping this simple
0) Works only with modules. Looks for '1;' before EOF
1) Each step defined on a single line in the original source.
    (probably have to change PerlTidy for 80+ character lines)
2) The Behavior ASSERTions are on the top.
3) You'll have to import subroutines from other modules
    (i.e. Wallet will not be resolved )
           my $asset = 'WALLET';
           my $package_base = 'Veure::Economy::Asset::';
           my $assetpackage = $package_base . $asset;
    (This be your opportunity) 
4) If an exception is caught (Try::Tiny), just gonna rethrow it!
     die $_; # rethrow
     Note: JT Smith's Ouch.pm is kool for creating exceptions.
5) In my sample code, individual *steps* will *NOT* be constructors (Ovid land)
6) Your project needs to create it's own begin, end and rollback transaction
   subroutines.
7) Subroutines used in a step return FALSE for bad, else everything is ok.

-------------------------------------------------

->  Disclaimers  <-

1) FSA::Rules does NOT have 'import' methods so I did NOT create
   one use/include package. (i.e. Modern::Perl)

2) 'Steps' must be an last argument to another subroutine/method.
   Otherwise the source filter will create a syntax error.


-------------------------------------------------

->  The Source Filter Will ...  <-

Handle this format of a procedure like call

my $rc = Steps(
            'arg1',
            one('stuff'),
            two('more stuff'),
         );

*========================================================*
The assignment statement before the 'Steps(' trips
the flag.

-------------------------------------------------

->  Use Template(s) For Your Coding  <-

Otherwise your amount of chanting will increase.

AND

You will be spending time in the debugger to see what the source filter created.


ex: 
    perl -d  run.pl
    f lib/PurchaseClones.pm
    |  l 1-400

-------------------------------------------------

->  Post Mortem  <-

What I used of FSA::Rules did not give a great advantage. 
I would got back to passing Array of Arrays and use
anonymous subroutines.

my $argz1 = [
        [ 'ASSERT', (sub {my @x; say "anon steps"; return 99}), ],
        ...
       ];

-------------------------------------------------

->  Ovid's Communications on the topic  <-
Posted on December 15, 2016 [The Tau Station Universe: Software](https://blog.taustation.space/blog/the-tau-station-universe-software/)

Posted on April 20, 2017    [On writing clean code](https://blog.taustation.space/blog/on-writing-clean-code/)

Posted on June 13, 2017     [Writing Declarative Perl](http://blogs.perl.org/users/ovid/2017/06/writing-declarative-perl.html)

Posted on February 8, 2018  [On writing clean code … for combat](https://blog.taustation.space/blog/on-writing-clean-code-for-combat/)

Posted on April 20, 2018    [Extending Economic Exchange Conditions](https://blog.taustation.space/blog/extending-economic-exchange-conditions/)

[Modeling a Universe in Perl](http://www.perlconference.us/tpc-2017-dc/talks/#modeling_a_universe_in_perl)
[Video](https://www.youtube.com/watch?v=UmLwYLSmTSs)

-------------------------------------------------

-> A 'Modeling a Universe' update.

At the Swiss Perl WorkShop 2018, Mr. Poe presentation:
1) Did not mention Behaviors
2) He said Tau Station does not do any logging
   But
     Any Economic Exchange that fails creates a
     'Error Report' of the entire 'Steps' call
      with field filled in instead of variable names.
      [ Day 1, 41st minute ]
     Probably why he uses constructors, return an
     object that has more than just a return code.

-------------------------------------------------

-> *The End. Questions?????* <-

1) Use JT Smith's [Ouch](http://search.cpan.org/~rizen/Ouch-0.0500/lib/Ouch.pm) module for exceptions!!!

2) Purchase Mr. Curtis Poe's Books
      Perl Hacks
      Beginning Perl
   Hang out at Tau Station
   Blogs (blogs.perl.org/users/ovid/) and (blog.taustation.space/blog/)

3) Complete code will be on the MadMongers' github page
     [MadMongers/09-2018-EconomicExchange](https://github.com/MadMongers/09-2018-EconomicExchange)

My Professional Bull Riders flack jacket sponsors are:
     [The Game Crafter](https://www.thegamecrafter.com)       Make your *DREAM* Board Game come TRUE
     [Table Top Events](https://tabletop.events)       Your *NEXT* Convention Management System (in the cloud)
     [Twit.tv](https://twit.tv)                If it has a chip in it, we'll be talking about it

